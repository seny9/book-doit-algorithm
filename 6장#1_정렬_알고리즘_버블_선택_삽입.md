# 6장_정렬_알고리즘_버블/선택/삽입

## 정렬 알고리즘

### 정렬

- 우리가 원하는 핵심 항목(key)의 대소 관계에 따라 데이터 집합을 일정한 순서로 나열하는 작업이다.
- 대체로 정렬을 하는 이유는 검색을 용이하게 하기 위해서다.
- 안정된 배열은 key값이 같은 요소의 순서가 정렬전후에도 유지되는 것이다.
    - 학번 순으로 나열된 키(height)값이 정렬 후에 같은 키값에 대해서 학번 순이 유지됨
- 하나의 배열에서 정렬하는데 메모리가 충분한 경우를 내부정렬, 그렇지 않은 경우는 외부정렬이라고 한다.
- 정렬 알고리즘은 교환, 선택, 삽입을 응용해서 구현한다.

<br>

---

### 버블 정렬(교환 정렬)

- 이웃한 두 요소의 대소 관계를 비교하고 필요에 따라 교환을 반복하는 알고리즘이다.
- 교환 정렬이라고도 한다.
- 알고리즘 사이클(오름차순 기준, 배열의 끝부터 비교)
    1. 인덱스 n-1요소와 n-2요소와 비교
    2. n-1이 더 작다면 교환
    3. 1,2를 인덱스 하나씩 줄여가며 0까지 수행
    4. 인덱스 0 정렬완료
- **n-1번 비교, n-2번 비교, …1번 비교까지 총 n*(n-1)/2번 비교**
- **O(n^2) 시간복잡도**

<br>

**코어 알고리즘(오름차순 기준, 배열의 끝부터 비교)**

```java
static void bubbleSort(int[] arr, int n) {
	for (int i = 0; i < n - 1; i++) { //정렬 완료된 부분
		for (int j = n - 1; j > i; j--) { //정렬수행 할 부분
			if (arr[j - 1] > arr[j]) // 정렬 위배
				swap(arr, j - 1, j);
		}
	}
}
```

- 실제 요소를 교환(이동)하는 복잡도는 요소의 개수에 영향을 받는다.
- 따라서 교환 횟수 평균은  비교횟수의 절반인 n(n-1)4
    - 2번 비교할 때 1번정도 실제로 교환한다.
- 코드에서 swap으로 비교하는 요소들이 세번 이동하는 것을 고려했을 때 이동 횟수 평균은 3*n(n-1)

- 비교 및 교환 과정(배열 끝에서 출발, 오름차순 정렬)

![Untitled](https://user-images.githubusercontent.com/69182630/223925540-50f2150f-2cae-4094-9453-d5ce3ec5c472.png)


<br>
<br>

**버블정렬 개선하기1**

- 버블 정렬은 n-1번부터 1번비교까지 비교를 **무조건** 수행한다.
- 이 말은 중간에 이미 배열이 정렬이 된 상태여도 비교연산이 계속 일어난다는 것.
- 따라서 비효율적인 작업을 없애기 위해 중간에 정렬할 요소가 더이상 없다면 멈춰주는 작업이 필요하다.

**개선한 코어 알고리즘1(오름차순 기준, 배열의 끝부터 비교)**

```java
static void bubbleSort(int[] arr, int n) {
	for (int i = 0; i < n - 1; i++) { //정렬 완료된 부분
		int exNum = 0; //한 사이클에서 교환되는 횟수
		for (int j = n - 1; j > i; j--) { //정렬수행 할 부분
			if (arr[j - 1] > arr[j]){ // 정렬 위배
				swap(arr, j - 1, j);
				exNum++;
			}		
		}
		if(exNum == 0) //더이상 교환할 요소가 없다
			break;
	}
}
```

<br>

![Untitled](https://user-images.githubusercontent.com/69182630/223925829-81ffd165-be81-4a37-a9b9-31395428eaca.png)

위의 예시는 첫번째 패스에 5와 4만 교환한 후 다음 패스에 중단


<br>
<br>

**버블정렬 개선하기2**

- 정렬 한 사이클에서 마지막 교환이 일어난 부분에 대해서
- 다음 턴의 정렬을 수행할 때는 마지막 교환이 일어난 인덱스 +1까지만 정렬 작업을 해줘도 된다.
- 이것 또한 비효율적인 비교연산을 줄여준다.

**개선한 코어 알고리즘2(오름차순 기준, 배열의 끝부터 비교)**

```java
static void bubbleSort(int[] arr, int n) {
		int done = 0; // arr[done] 앞부분은 정렬완료
		while (done < n - 1) { // done이 n-2고 n-1에 대해서 정렬할 때까지
			int last = n - 1; // 마지막 교환 위치
			for (int j = n - 1; j > done; j--) { // done+1까지만 정렬 작업
				if (arr[j - 1] > arr[j]) {
					swap(arr, j - 1, j);
					last = j; // 마지막 교환 인덱스 갱신
				}
			}
			done = last; // 마지막 교환 인덱스까지 정렬 완료
		}
}
```

![Untitled](https://user-images.githubusercontent.com/69182630/223926353-01cc2ca9-3a0c-45ca-8b7a-6c11c280d1db.png)


패스2에서는 패스1에서의 마지막 교환 위치인 인덱스 1전까지만 정렬 작업 수행


<br>
<br>

**칵테일 셰이커 정렬(양방향 버블 정렬)**

- 기본 버블 정렬과는 다르게 매 패스마다 배열의 순서를 자꿔서 정렬한다.
- (오름차순 기준)홀수 번째 패스는 가장 작은 요소를 맨앞으로, 짝수 번째 패스는 가장 큰 요소를 맨 뒤로 보낸다.
- 매 패스마다 양 끝에서 번갈아서 정렬 완료요소가 하나씩 생긴다.
- O(n^2)


![Untitled](https://user-images.githubusercontent.com/69182630/223926595-d5329fbf-a305-49a8-b275-6d888e04bb0f.png)

<br>
<br>

---

### 단순 선택 정렬

- 가장 작은 요소부터 목표 위치 인덱스와 바로 교환하는 알고리즘이다.
- 0번째 작은 요소 찾음 → 인덱스 0과 교환, 1번째 작은 요소 찾음→ 인덱스 1과 교환 …
- 즉 정렬하지 않은 부분에서 가장 작은 값 골라 정렬하지 않은 부분의 첫번째 요소와 교환한다.
- **시간복잡도 O(n^2), 그래도 비교횟수에 비해 교환횟수는 적기 때문에 많은 교환이 일어나야 하는 때에 사용하기 효율적일 수 있다**

**코어 알고리즘**

```java
static void selectionSort(int[] a, int n){
	for(int i=0; i<n-1; i++){ //인덱스 i와 교환
		int min = i;
		for(int j=i+1; j<n; j++){
			if(a[j] < a[min]){
				min = j;
			}
		}
		swap(a, i, min);
	}
}
```

- 인덱스 0부터 시작해서 가장 작은 요소와 교환해나간다.
- 교환 횟수는 (n-1) + (n-2) + … + 1 → n * (n-1)/2

- 하지만 선택 알고리즘은 요소의 교환을 목표 요소를 찾는다면 바로 목표인덱스와 비교 및 교환을 하기 때문에 안정적이지 못하다(=key값이 같은 요소의 순서가 정렬전후에도 유지못할 수 있다)

<br>
<br>

---

### 단순 삽입 정렬

- 두번째 요소부터 시작해서 정렬되지 않은 부분의 요소들을 차례로 **알맞은 위치에 삽입**하는 알고리즘이다.
- 알맞은 위치에 삽입?(오름차순 기준)
    - a[i]가 a[i-1]보다 작은 경우
    - tmp = a[i]
    - tmp보다 작거나 같은 값 나올 때까지 a[i—] = a[i-1]
    - a[i-1] ≤ tmp 경우 a[i] = tmp
- **시간복잡도 O(n^2), 하나씩 비교하면서 하나씩 민다는 점에서  정렬이전 상태, 배열크기에 영향을 많이 받는다고 할 수 있다.**

**코어 알고리즘**

```java
static void insertionSort(int[] a, int n){
	for(int i=1; i<n; i++){
		int j;
		int tmp = a[i];
		for(j=i; j>0 && a[j-1] > tmp; j--) //인덱스 0이상이면서 tmp요소보다 큰 요소들
			a[j] = a[j-1]; //요소 뒤로 밀기
		a[j] = tmp; //tmp보다 작은 요소 바로 다음에 배치
	}
}
```

<br>
<br>