# 5장#1_재귀_알고리즘_기본_분석

## 재귀 알고리즘

### 재귀란

```java
어떤 사건이 자신을 포함하거나 자신을 사용해서 정의하는 것
```

재귀를 잘 사용하면 프로그램을 간결하게 작성 가능하다.

- 풀어야 할 문제나 계산할 메소드, 처리할 자료구조가 재귀로 구현되기에 알맞은지 확인한다.
- 재귀는 호출될 때마다 베소드의 복사본이 메모리에 만들어진다. 따라서 스택(메모리)의 추가공간이 필요하다. 따라서 일반적으로 반복방법이 재귀방법보다 효율적이다.
- 재귀 알고리즘들
    - 피보나치, 팩토리얼
    - 머지정렬, 퀵정렬
    - 이진검색
    - 트리 탐색
    - 동적 계획법
    - 분할 정복 알고리즘
    - 하노이의 탑
    - 백트래킹

<br>

**팩토리얼 구하기**

```java
static int factorial(int n){
	if(n > 0){ //0이 아닌 경우
		return n * factorial(n-1); //재귀 구현
	else
		return 1;
}
```

```java
return n > 0 ? n * factorial(n-1) : 1;
```

- 5! 구하는 경우
    
    5 * factorial(4)
    
    → 4 * factorial(3)
    
    → 3 * factorial(2)
    
    → 2 * factorial(1)
    
    → 1 * factorial(0)
    
    → 1

<br>

**직접 재귀와 간접 재귀**

직접 재귀: 메소드A가 자신과 동일한 메소드를 호출하는 방식

간접 재귀: 메소드A가 메소드B를 호출하고 다시 메소드B가 메소드A를 호출하는 방식

<br>

**유클리드 호제법**

- 논리흐름
    1. 직사각형을 정사각형으로 빈틈없이 채운다
        1. 길이가 긴 변이 짧은 변으로 나누어 떨어지면 길이가 짧은 변이 최대공약수
        2. **나누어떨어지지 않으면 긴 변을 작은 변과 나머지로 나누어 떨어질 때까지 재귀**
    2. 남은 직사각형을 또 다른 정사각형으로 빈틈없이 채운다
    3. 1과 2를 반복한다.
    
    → 두 정수의 최대공약수(Greatest Common divisor) 구하기
    

- 알고리즘
    
    길이가 긴변을 x, 길이가 짧은 변을 y라고 했을 경우
    
    y가 0이 아니라면,
    
    y와, x%y의 최대공약수를 구한다. getRslt(y, x%y)
    
    y가 0이라면,
    
    x가 최대공약수. return x
    
    ```java
    public static int gcd(int n1, int n2) {
    		if(n2 == 0)
    			return n1;
    		else {
    			return gcd(n2, n1%n2);
    		}
    	}
    ```
    
<br>
<br>

**배열의 모든 요소의 최대공약수 구하기**

```java
public static int gcdArray(int[] a) {
		
		int len = a.length;
		if(len == 1) //배열 요소 하나인 경우
			return a[0];
		
		//처음 두 요소의 최대공약수 구하기
		int rslt = gcd(a[0], a[1]);
		
		//2번째 요소부터 gcd(최대공약수, a[i])
		for(int i=2; i<len; i++) {
			if(rslt == 1) //최대공약수가 1이 나올 경우 멈춤
				break;
			rslt = gcd(rslt, a[i]);
		}
		return rslt;
	}
```

제일 처음 두 수의 최대공약수를 구한 다음 그 이후의 배열요소와 하나씩 최대공약수를 구해간다.

---

## 재귀 알고리즘 분석

**분석방법**

- 하향식 분석
    
    가장 처음 호출된 메소드를 상위 메소드라고 하고 재귀적으로 호출되는 메소드들을 하위 메소드들이라고 할 때 상위에서 하위로 계단식 조사를 해가는 분석 방법이다.
    
    가장 상위 메소드부터 분석하다 보면 같은 메소드를 여러번 호출할 수 있어 효율적이지 않을 수 있다.
    
- 상향식 분석
    
    아래부터 쌓아 올리며 분석하는 방법이다. 가장 아랫단인 0이나 1이 매개변수로 주어졌을 때부터 시작해서 n까지 올라간다.
    
    하향식 분석과는 다르게 불필요한 중복 메소드 호출을 막을 수 있다.

<br>
    

### Q4. recur2 메소드 하향식 분석, 상향식 분석하기

```java
static void recur2(int n){
	if(n > 0){
		recur2(n-2);
		System.out.println(n);
		recur2(n-1);
	}
}
```

- n = 4일 경우
- 하향식
    
    recur2(2) - 4출력 - recur2(3)
    
    **{recur2(0) - 2출력 - recur2(1)}** - 4출력 - **{recur2(1) - 3출력 - recur2(2)}**
    
    2출력 - **{recur2(-1) - 1출력 - recur2(0)}** - 4출력 - **{recur2(-1) - 1출력 - recur2(0)}** - 3출력 - **{recur2(0) - 2출력 - recur2(1)}**
    
    2출력 - 1출력 - 4출력 - 1출력 - 3출력 ****- 2출력 - **{recur2(-1) - 1출력 - recur2(0)}**
    
    2 - 1 - 4 - 1 - 3 - 2 - 1

    
- 상향식
    
    n이 양수일 때만 유효하므로
    
    recur2(1) → recur2(-1) - 1출력 - recur2(0)
    
    recur2(2) → recur2(0) - 2출력 - recur2(1)
    
    recur2(3) → recur2(1) - 3출력 - recur2(2)
    
    recur2(4) → recur2(2) - 4출력 - recur2(3)
    
    2 - 1 - 4 - 1 - 3 - 2 - 1
    
<br>
<br>

**재귀 제거해보기**

메소드를 직접 호출해서 재귀를 사용할 때 이용되는 매개변수 값을 단순히 메소드 안에서 바꾸어준 후 메소드 시작지점으로 돌아간다. 이렇게 하면 메소드를 호출하는 재귀를 없앨 수 있다.

하지만 만약 재귀 호출이 두번 이상 사용된다면 메소드에 적용되는 매개변수 값이 달라지기 때문에 재귀를 제거할 수 없다.

```java
public void recur2(int n){
...
recur2(n); // 아래 코드보다 먼저 수행되어야 하기 때문에 없애기 쉽지 않다
recur2(n-1); // -> n -= 1?
...
}
```

이와 같은 문제는 변수를 저장해줘서 해결할 수 있다.

메소드 호출을 하지 않고 변수만 변경해서 메소드 구현 초반으로 돌아갈 수 있도록 한다.

재귀원리와 비슷한 자료구조인 스택을 이용한다. (내부가 모두 호출된 후 마지막에 껍데기 끝)

```java
static void recur(int n){
	IntStack s = new IntStack(n);

	while(true){
		if(n > 0){
			s.push(n); // 양수일 경우 스택에 저장
			n -= 1; // 재귀 알고리즘에 따라 변수 변경
			continue; //변경된 변수 n에 따라 함수 다시시작
		}
		if(s.isEmpty() != true){
			n = s.pop(); // n이 0이나 음수일 때 스택에서 팝(재귀 알고리즘 중 출력만 해주면 된다)
			System.out.println(n); // 재귀 알고리즘에 따라 변수 출력
			n = n - 2; // 재귀 알고리즘에 따라 변수 변경
			continue; //변경된 변수 n에 따라 함수 다시시작
		}
	}
}
```

<br>
<br>

**메모화**

재귀 메소드는 실행과정에서 같은 계산을 여러번 반복한다. 따라서 데이터의 규모가 커질수록 계산횟수는 많이 늘어난다.

메모화 기능을 사용하면 동일한 연산을 한번만 진행 할 수 있다.

재귀에 따른 매개변수에 따른 결괏값이 나오면 메모해둔다. 그리고 후에 동일한 재귀가 실행된다면 메모해둔 결과를 단순 문자열로 출력한다.

```java
static void recur(int n) {
        if (memo[n + 1] != null)
            System.out.print(memo[n + 1]);
        else {
            if (n > 0) {
                recur(n - 1);
                System.out.println(n);
                recur(n - 2);
                memo[n + 1] = memo[n] + n + "\n" + memo[n - 1]; //메모
            } else {
                memo[n + 1] = "";// n이 0과 -1은 빈 문자열
            }
        }
    }
```

memo[0] → “”

memo[1] → “”

memo[2] → 1

memo[3] → 1\n2

memo[4] → 1\n23\n1

memo[5] → 1\n23\n14\n1\n2

…

---

- 참고자료
    - 재귀란: [https://medium.com/@sunnkis/데이터-구조-재귀-8d96633be4cd](https://medium.com/@sunnkis/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0-%EC%9E%AC%EA%B7%80-8d96633be4cd)